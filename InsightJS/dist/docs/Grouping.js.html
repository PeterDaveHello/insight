<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>Source: mda/Grouping.js</title>
    
    
    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <script src="scripts/jquery.min.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/bootstrap.min.css">
    <link type="text/css" rel="stylesheet" href="styles/jaguar.css">
    
    
    <script>
    var config = {"monospaceLinks":false,"cleverLinks":false,"default":{"outputSourceFiles":true}};
    </script>
    

    
</head>
<body>
<div id="wrap" class="clearfix">
    
<div class="navigation">
    <h3 class="applicationName"><a href="index.html"></a></h3>

    <div class="search">
        <input id="search" type="text" class="form-control input-sm" placeholder="Search Documentations">
    </div>
    <ul class="list">
    
        <li class="item" data-name="insight">
            <span class="title">
                <a href="insight.html">insight</a>
                
                <span class="static">static</span>
                
            </span>
            <ul class="members itemMembers">
            
            </ul>
            <ul class="typedefs itemMembers">
            
            </ul>
            <ul class="methods itemMembers">
            
            </ul>
            <ul class="events itemMembers">
            
            </ul>
        </li>
    
        <li class="item" data-name="insight.Axis">
            <span class="title">
                <a href="insight.Axis.html">insight.Axis</a>
                
            </span>
            <ul class="members itemMembers">
            
            </ul>
            <ul class="typedefs itemMembers">
            
            </ul>
            <ul class="methods itemMembers">
            
            <span class="subtitle">Methods</span>
            
                <li data-name="insight.Axis.this.horizontal"><a href="insight.Axis.html#this.horizontal">this.horizontal</a></li>
            
                <li data-name="insight.Axis#this.calculateAxisBounds"><a href="insight.Axis.html##this.calculateAxisBounds">#this.calculateAxisBounds</a></li>
            
                <li data-name="insight.Axis#this.color"><a href="insight.Axis.html##this.color">#this.color</a></li>
            
                <li data-name="insight.Axis#this.color"><a href="insight.Axis.html##this.color">#this.color</a></li>
            
                <li data-name="insight.Axis#this.display"><a href="insight.Axis.html##this.display">#this.display</a></li>
            
                <li data-name="insight.Axis#this.display"><a href="insight.Axis.html##this.display">#this.display</a></li>
            
                <li data-name="insight.Axis#this.domain"><a href="insight.Axis.html##this.domain">#this.domain</a></li>
            
                <li data-name="insight.Axis#this.ordered"><a href="insight.Axis.html##this.ordered">#this.ordered</a></li>
            
                <li data-name="insight.Axis#this.ordered"><a href="insight.Axis.html##this.ordered">#this.ordered</a></li>
            
                <li data-name="insight.Axis#this.reversed"><a href="insight.Axis.html##this.reversed">#this.reversed</a></li>
            
                <li data-name="insight.Axis#this.reversed"><a href="insight.Axis.html##this.reversed">#this.reversed</a></li>
            
                <li data-name="insight.Axis#this.showGridlines"><a href="insight.Axis.html##this.showGridlines">#this.showGridlines</a></li>
            
                <li data-name="insight.Axis#this.showGridlines"><a href="insight.Axis.html##this.showGridlines">#this.showGridlines</a></li>
            
                <li data-name="insight.Axis#this.zoomable"><a href="insight.Axis.html##this.zoomable">#this.zoomable</a></li>
            
                <li data-name="insight.Axis#this.zoomable"><a href="insight.Axis.html##this.zoomable">#this.zoomable</a></li>
            
                <li data-name="insight.Axis~findMax"><a href="insight.Axis.html#findMax">findMax</a></li>
            
                <li data-name="insight.Axis~findMin"><a href="insight.Axis.html#findMin">findMin</a></li>
            
            </ul>
            <ul class="events itemMembers">
            
            </ul>
        </li>
    
        <li class="item" data-name="insight.AxisGridlines">
            <span class="title">
                <a href="insight.AxisGridlines.html">insight.AxisGridlines</a>
                
            </span>
            <ul class="members itemMembers">
            
            </ul>
            <ul class="typedefs itemMembers">
            
            </ul>
            <ul class="methods itemMembers">
            
            <span class="subtitle">Methods</span>
            
                <li data-name="insight.AxisGridlines#this.allGridlines"><a href="insight.AxisGridlines.html##this.allGridlines">#this.allGridlines</a></li>
            
                <li data-name="insight.AxisGridlines#this.lineColor"><a href="insight.AxisGridlines.html##this.lineColor">#this.lineColor</a></li>
            
                <li data-name="insight.AxisGridlines#this.lineColor"><a href="insight.AxisGridlines.html##this.lineColor">#this.lineColor</a></li>
            
                <li data-name="insight.AxisGridlines#this.lineWidth"><a href="insight.AxisGridlines.html##this.lineWidth">#this.lineWidth</a></li>
            
                <li data-name="insight.AxisGridlines#this.lineWidth"><a href="insight.AxisGridlines.html##this.lineWidth">#this.lineWidth</a></li>
            
            </ul>
            <ul class="events itemMembers">
            
            </ul>
        </li>
    
        <li class="item" data-name="insight.BubbleSeries">
            <span class="title">
                <a href="insight.BubbleSeries.html">insight.BubbleSeries</a>
                
            </span>
            <ul class="members itemMembers">
            
            </ul>
            <ul class="typedefs itemMembers">
            
            </ul>
            <ul class="methods itemMembers">
            
            <span class="subtitle">Methods</span>
            
                <li data-name="insight.BubbleSeries#this.radiusFunction"><a href="insight.BubbleSeries.html##this.radiusFunction">#this.radiusFunction</a></li>
            
                <li data-name="insight.BubbleSeries#this.radiusFunction"><a href="insight.BubbleSeries.html##this.radiusFunction">#this.radiusFunction</a></li>
            
            </ul>
            <ul class="events itemMembers">
            
            </ul>
        </li>
    
        <li class="item" data-name="insight.Chart">
            <span class="title">
                <a href="insight.Chart.html">insight.Chart</a>
                
            </span>
            <ul class="members itemMembers">
            
            </ul>
            <ul class="typedefs itemMembers">
            
            </ul>
            <ul class="methods itemMembers">
            
            <span class="subtitle">Methods</span>
            
                <li data-name="insight.Chart.this.highlight"><a href="insight.Chart.html#this.highlight">this.highlight</a></li>
            
                <li data-name="insight.Chart.this.seriesChanged"><a href="insight.Chart.html#this.seriesChanged">this.seriesChanged</a></li>
            
                <li data-name="insight.Chart#calculateLabelMargin"><a href="insight.Chart.html##calculateLabelMargin">#calculateLabelMargin</a></li>
            
                <li data-name="insight.Chart#this.addXAxis"><a href="insight.Chart.html##this.addXAxis">#this.addXAxis</a></li>
            
                <li data-name="insight.Chart#this.addYAxis"><a href="insight.Chart.html##this.addYAxis">#this.addYAxis</a></li>
            
                <li data-name="insight.Chart#this.height"><a href="insight.Chart.html##this.height">#this.height</a></li>
            
                <li data-name="insight.Chart#this.height"><a href="insight.Chart.html##this.height">#this.height</a></li>
            
                <li data-name="insight.Chart#this.legend"><a href="insight.Chart.html##this.legend">#this.legend</a></li>
            
                <li data-name="insight.Chart#this.legend"><a href="insight.Chart.html##this.legend">#this.legend</a></li>
            
                <li data-name="insight.Chart#this.margin"><a href="insight.Chart.html##this.margin">#this.margin</a></li>
            
                <li data-name="insight.Chart#this.margin"><a href="insight.Chart.html##this.margin">#this.margin</a></li>
            
                <li data-name="insight.Chart#this.maxWidth"><a href="insight.Chart.html##this.maxWidth">#this.maxWidth</a></li>
            
                <li data-name="insight.Chart#this.maxWidth"><a href="insight.Chart.html##this.maxWidth">#this.maxWidth</a></li>
            
                <li data-name="insight.Chart#this.minWidth"><a href="insight.Chart.html##this.minWidth">#this.minWidth</a></li>
            
                <li data-name="insight.Chart#this.minWidth"><a href="insight.Chart.html##this.minWidth">#this.minWidth</a></li>
            
                <li data-name="insight.Chart#this.resizeWidth"><a href="insight.Chart.html##this.resizeWidth">#this.resizeWidth</a></li>
            
                <li data-name="insight.Chart#this.series"><a href="insight.Chart.html##this.series">#this.series</a></li>
            
                <li data-name="insight.Chart#this.series"><a href="insight.Chart.html##this.series">#this.series</a></li>
            
                <li data-name="insight.Chart#this.width"><a href="insight.Chart.html##this.width">#this.width</a></li>
            
                <li data-name="insight.Chart#this.width"><a href="insight.Chart.html##this.width">#this.width</a></li>
            
                <li data-name="insight.Chart#this.xAxes"><a href="insight.Chart.html##this.xAxes">#this.xAxes</a></li>
            
                <li data-name="insight.Chart#this.xAxes"><a href="insight.Chart.html##this.xAxes">#this.xAxes</a></li>
            
                <li data-name="insight.Chart#this.xAxis"><a href="insight.Chart.html##this.xAxis">#this.xAxis</a></li>
            
                <li data-name="insight.Chart#this.xAxis"><a href="insight.Chart.html##this.xAxis">#this.xAxis</a></li>
            
                <li data-name="insight.Chart#this.yAxes"><a href="insight.Chart.html##this.yAxes">#this.yAxes</a></li>
            
                <li data-name="insight.Chart#this.yAxes"><a href="insight.Chart.html##this.yAxes">#this.yAxes</a></li>
            
                <li data-name="insight.Chart#this.yAxis"><a href="insight.Chart.html##this.yAxis">#this.yAxis</a></li>
            
                <li data-name="insight.Chart#this.yAxis"><a href="insight.Chart.html##this.yAxis">#this.yAxis</a></li>
            
                <li data-name="insight.Chart#this.zoomable"><a href="insight.Chart.html##this.zoomable">#this.zoomable</a></li>
            
            </ul>
            <ul class="events itemMembers">
            
            </ul>
        </li>
    
        <li class="item" data-name="insight.ChartGroup">
            <span class="title">
                <a href="insight.ChartGroup.html">insight.ChartGroup</a>
                
            </span>
            <ul class="members itemMembers">
            
            </ul>
            <ul class="typedefs itemMembers">
            
            </ul>
            <ul class="methods itemMembers">
            
            <span class="subtitle">Methods</span>
            
                <li data-name="insight.ChartGroup#this.add"><a href="insight.ChartGroup.html##this.add">#this.add</a></li>
            
                <li data-name="insight.ChartGroup#this.chartFilterHandler"><a href="insight.ChartGroup.html##this.chartFilterHandler">#this.chartFilterHandler</a></li>
            
                <li data-name="insight.ChartGroup#this.draw"><a href="insight.ChartGroup.html##this.draw">#this.draw</a></li>
            
            </ul>
            <ul class="events itemMembers">
            
            </ul>
        </li>
    
        <li class="item" data-name="insight.ColumnSeries">
            <span class="title">
                <a href="insight.ColumnSeries.html">insight.ColumnSeries</a>
                
            </span>
            <ul class="members itemMembers">
            
            </ul>
            <ul class="typedefs itemMembers">
            
            </ul>
            <ul class="methods itemMembers">
            
            <span class="subtitle">Methods</span>
            
                <li data-name="insight.ColumnSeries#this.findMax"><a href="insight.ColumnSeries.html##this.findMax">#this.findMax</a></li>
            
                <li data-name="insight.ColumnSeries#this.stacked"><a href="insight.ColumnSeries.html##this.stacked">#this.stacked</a></li>
            
                <li data-name="insight.ColumnSeries#this.stacked"><a href="insight.ColumnSeries.html##this.stacked">#this.stacked</a></li>
            
            </ul>
            <ul class="events itemMembers">
            
            </ul>
        </li>
    
        <li class="item" data-name="insight.DataSet">
            <span class="title">
                <a href="insight.DataSet.html">insight.DataSet</a>
                
            </span>
            <ul class="members itemMembers">
            
            </ul>
            <ul class="typedefs itemMembers">
            
            </ul>
            <ul class="methods itemMembers">
            
            </ul>
            <ul class="events itemMembers">
            
            </ul>
        </li>
    
        <li class="item" data-name="insight.Dimension">
            <span class="title">
                <a href="insight.Dimension.html">insight.Dimension</a>
                
            </span>
            <ul class="members itemMembers">
            
            </ul>
            <ul class="typedefs itemMembers">
            
            </ul>
            <ul class="methods itemMembers">
            
            <span class="subtitle">Methods</span>
            
                <li data-name="insight.Dimension.this.createFilterFunction"><a href="insight.Dimension.html#this.createFilterFunction">this.createFilterFunction</a></li>
            
            </ul>
            <ul class="events itemMembers">
            
            </ul>
        </li>
    
        <li class="item" data-name="insight.Legend">
            <span class="title">
                <a href="insight.Legend.html">insight.Legend</a>
                
            </span>
            <ul class="members itemMembers">
            
            </ul>
            <ul class="typedefs itemMembers">
            
            </ul>
            <ul class="methods itemMembers">
            
            </ul>
            <ul class="events itemMembers">
            
            </ul>
        </li>
    
        <li class="item" data-name="insight.LineSeries">
            <span class="title">
                <a href="insight.LineSeries.html">insight.LineSeries</a>
                
            </span>
            <ul class="members itemMembers">
            
            </ul>
            <ul class="typedefs itemMembers">
            
            </ul>
            <ul class="methods itemMembers">
            
            <span class="subtitle">Methods</span>
            
                <li data-name="insight.LineSeries#this.showPoints"><a href="insight.LineSeries.html##this.showPoints">#this.showPoints</a></li>
            
                <li data-name="insight.LineSeries#this.showPoints"><a href="insight.LineSeries.html##this.showPoints">#this.showPoints</a></li>
            
            </ul>
            <ul class="events itemMembers">
            
            </ul>
        </li>
    
        <li class="item" data-name="insight.MarginMeasurer">
            <span class="title">
                <a href="insight.MarginMeasurer.html">insight.MarginMeasurer</a>
                
            </span>
            <ul class="members itemMembers">
            
            </ul>
            <ul class="typedefs itemMembers">
            
            </ul>
            <ul class="methods itemMembers">
            
            <span class="subtitle">Methods</span>
            
                <li data-name="insight.MarginMeasurer#self.calculateChartMargins"><a href="insight.MarginMeasurer.html##self.calculateChartMargins">#self.calculateChartMargins</a></li>
            
                <li data-name="insight.MarginMeasurer#self.seriesLabelDimensions"><a href="insight.MarginMeasurer.html##self.seriesLabelDimensions">#self.seriesLabelDimensions</a></li>
            
            </ul>
            <ul class="events itemMembers">
            
            </ul>
        </li>
    
        <li class="item" data-name="insight.MarkerSeries">
            <span class="title">
                <a href="insight.MarkerSeries.html">insight.MarkerSeries</a>
                
            </span>
            <ul class="members itemMembers">
            
            </ul>
            <ul class="typedefs itemMembers">
            
            </ul>
            <ul class="methods itemMembers">
            
            <span class="subtitle">Methods</span>
            
                <li data-name="insight.MarkerSeries#this.widthFactor"><a href="insight.MarkerSeries.html##this.widthFactor">#this.widthFactor</a></li>
            
                <li data-name="insight.MarkerSeries#this.widthFactor"><a href="insight.MarkerSeries.html##this.widthFactor">#this.widthFactor</a></li>
            
            </ul>
            <ul class="events itemMembers">
            
            </ul>
        </li>
    
        <li class="item" data-name="insight.RowSeries">
            <span class="title">
                <a href="insight.RowSeries.html">insight.RowSeries</a>
                
            </span>
            <ul class="members itemMembers">
            
            </ul>
            <ul class="typedefs itemMembers">
            
            </ul>
            <ul class="methods itemMembers">
            
            <span class="subtitle">Methods</span>
            
                <li data-name="insight.RowSeries#this.findMax"><a href="insight.RowSeries.html##this.findMax">#this.findMax</a></li>
            
                <li data-name="insight.RowSeries#this.seriesMax"><a href="insight.RowSeries.html##this.seriesMax">#this.seriesMax</a></li>
            
                <li data-name="insight.RowSeries#this.stacked"><a href="insight.RowSeries.html##this.stacked">#this.stacked</a></li>
            
                <li data-name="insight.RowSeries#this.stacked"><a href="insight.RowSeries.html##this.stacked">#this.stacked</a></li>
            
            </ul>
            <ul class="events itemMembers">
            
            </ul>
        </li>
    
        <li class="item" data-name="insight.ScatterSeries">
            <span class="title">
                <a href="insight.ScatterSeries.html">insight.ScatterSeries</a>
                
            </span>
            <ul class="members itemMembers">
            
            </ul>
            <ul class="typedefs itemMembers">
            
            </ul>
            <ul class="methods itemMembers">
            
            </ul>
            <ul class="events itemMembers">
            
            </ul>
        </li>
    
        <li class="item" data-name="insight.Series">
            <span class="title">
                <a href="insight.Series.html">insight.Series</a>
                
            </span>
            <ul class="members itemMembers">
            
            </ul>
            <ul class="typedefs itemMembers">
            
            </ul>
            <ul class="methods itemMembers">
            
            <span class="subtitle">Methods</span>
            
                <li data-name="insight.Series#this.dataset"><a href="insight.Series.html##this.dataset">#this.dataset</a></li>
            
                <li data-name="insight.Series#this.findMax"><a href="insight.Series.html##this.findMax">#this.findMax</a></li>
            
                <li data-name="insight.Series#this.findMin"><a href="insight.Series.html##this.findMin">#this.findMin</a></li>
            
                <li data-name="insight.Series#this.keyFunction"><a href="insight.Series.html##this.keyFunction">#this.keyFunction</a></li>
            
                <li data-name="insight.Series#this.keyFunction"><a href="insight.Series.html##this.keyFunction">#this.keyFunction</a></li>
            
                <li data-name="insight.Series#this.tooltipOffset"><a href="insight.Series.html##this.tooltipOffset">#this.tooltipOffset</a></li>
            
                <li data-name="insight.Series#this.tooltipOffset"><a href="insight.Series.html##this.tooltipOffset">#this.tooltipOffset</a></li>
            
                <li data-name="insight.Series#this.valueFunction"><a href="insight.Series.html##this.valueFunction">#this.valueFunction</a></li>
            
                <li data-name="insight.Series#this.valueFunction"><a href="insight.Series.html##this.valueFunction">#this.valueFunction</a></li>
            
            </ul>
            <ul class="events itemMembers">
            
            </ul>
        </li>
    
        <li class="item" data-name="insight.Table">
            <span class="title">
                <a href="insight.Table.html">insight.Table</a>
                
            </span>
            <ul class="members itemMembers">
            
            </ul>
            <ul class="typedefs itemMembers">
            
            </ul>
            <ul class="methods itemMembers">
            
            <span class="subtitle">Methods</span>
            
                <li data-name="insight.Table#this.ascending"><a href="insight.Table.html##this.ascending">#this.ascending</a></li>
            
                <li data-name="insight.Table#this.columns"><a href="insight.Table.html##this.columns">#this.columns</a></li>
            
                <li data-name="insight.Table#this.columns"><a href="insight.Table.html##this.columns">#this.columns</a></li>
            
                <li data-name="insight.Table#this.descending"><a href="insight.Table.html##this.descending">#this.descending</a></li>
            
                <li data-name="insight.Table#this.keyFunction"><a href="insight.Table.html##this.keyFunction">#this.keyFunction</a></li>
            
                <li data-name="insight.Table#this.keyFunction"><a href="insight.Table.html##this.keyFunction">#this.keyFunction</a></li>
            
                <li data-name="insight.Table#this.top"><a href="insight.Table.html##this.top">#this.top</a></li>
            
                <li data-name="insight.Table#this.top"><a href="insight.Table.html##this.top">#this.top</a></li>
            
            </ul>
            <ul class="events itemMembers">
            
            </ul>
        </li>
    
        <li class="item" data-name="insight.Tooltip">
            <span class="title">
                <a href="insight.Tooltip.html">insight.Tooltip</a>
                
            </span>
            <ul class="members itemMembers">
            
            </ul>
            <ul class="typedefs itemMembers">
            
            </ul>
            <ul class="methods itemMembers">
            
            <span class="subtitle">Methods</span>
            
                <li data-name="insight.Tooltip#this.hide"><a href="insight.Tooltip.html##this.hide">#this.hide</a></li>
            
                <li data-name="insight.Tooltip#this.offset"><a href="insight.Tooltip.html##this.offset">#this.offset</a></li>
            
                <li data-name="insight.Tooltip#this.offset"><a href="insight.Tooltip.html##this.offset">#this.offset</a></li>
            
                <li data-name="insight.Tooltip#this.show"><a href="insight.Tooltip.html##this.show">#this.show</a></li>
            
                <li data-name="insight.Tooltip#this.styles"><a href="insight.Tooltip.html##this.styles">#this.styles</a></li>
            
                <li data-name="insight.Tooltip#this.styles"><a href="insight.Tooltip.html##this.styles">#this.styles</a></li>
            
            </ul>
            <ul class="events itemMembers">
            
            </ul>
        </li>
    
    </ul>
</div>
    <div class="main">
        <h1 class="page-title" data-filename="Grouping.js.html">Source: mda/Grouping.js</h1>
        


    
    <section>
        <article>
            <pre class="prettyprint source"><code>/**
 * A Grouping is generated on a dimension, to reduce the items in the data set into groups along the provided dimension
 * @class insight.Grouping
 * @constructor
 * @param {dimension} dimension - The dimension to group
 */
(function(insight) {

    insight.Grouping = function Grouping(dimension) {

        // Private variables

        var sumProperties = [],
            countProperties = [],
            cumulativeProperties = [],
            averageProperties = [],
            correlationPairProperties = [],
            allCorrelationProperties = [],
            ordered = false,
            self = this,
            filterFunction = null,
            orderFunction;

        // Public variables
        self.dimension = dimension;

        // Private methods

        // The default post aggregation step is blank, and can be overriden by users if they want to calculate additional values with this Grouping
        var postAggregation = function(grouping) {

        };

        /*
         * Takes an object and a property name in the form of a string, traversing the object until it finds a property with that name and returning
         * a wrapped object with the immediate parent of the found property and the property's value.
         * @param {object} - The object to search
         * @param {string} propertyName - A string of the property to search, can include sub-properties using a dot notation. Eg. 'value.Revenue.Sum', which cannot be indexed directly in Javascript.
         */
        var getDescendant = function(obj, propertyName) {
            var arr = propertyName.split(".");
            var name = propertyName;
            var container = null;

            while (arr.length) {
                name = arr.shift();
                container = obj;
                obj = obj[name];
            }
            return {
                container: container,
                value: obj,
                propertyName: name
            };
        };

        /*
         * Takes a group object and calculates the mean for any properties configured.
         * @param {object} group - A dimensional slice of a Grouping {key: 'X', value : {}}
         */
        var calculateAverages = function(group) {


            for (var i = 0, len = averageProperties.length; i &lt; len; i++) {

                var propertyName = averageProperties[i];
                var propertyValue = group.value[propertyName];
                var mean = propertyValue.Sum / group.value.Count;

                mean = insight.Utils.isNumber(mean) && isFinite(mean) ? mean : 0;

                group.value[propertyName].Average = mean;
            }
        };

        /*
         * Calculates running cumulative values for any properties defined in the cumulative() list.
         * @param {object} group - The data group being added to the cumulative running totals list
         * @param {object} totals - The map object of running totals for the defined properties
         */
        var calculateCumulativeValues = function(group, totals) {

            var propertyName,
                descendant;

            for (var i = 0, len = cumulativeProperties.length; i &lt; len; i++) {

                propertyName = cumulativeProperties[i];
                descendant = getDescendant(group.value, propertyName);

                var totalName = descendant.propertyName + 'Cumulative';

                totals[totalName] = totals[totalName] ? totals[totalName] + descendant.value : descendant.value;

                descendant.container[totalName] = totals[totalName];

            }

            return totals;
        };

        /*
         * Calculates correlation coefficient values for all configured property pairs on the grouping.
         * So after this function has run there will be a number of properties on the grouping value called
         * 'X_Cor_Y' where X and Y are the configured property names.
         */
        var calculateCorrelations = function() {

            /*
             * Returns a property name for the deviation product array used in the correlation workings
             */
            var deviationProductNameFunction = function(xName, yName) {

                return xName + '_' + yName + '_DeviationProduct';

            };

            /*
             * Returns an empty object that will contain the correlation working data
             */
            var correlationReduceInitialize = function() {

                return {};

            };

            /*
             * Returns the function to use for creating a reduciton of all groups in order to calculate correlation
             * between properties in a group.
             */
            var correlationReduceAdd = function(aggregatedData) {

                var globalData = aggregatedData;

                /*
                 * This is the function that does the reduction to produce working data for correlation calculations.
                 */
                return function(workings, addingData) {

                    allCorrelationProperties.forEach(function(propertyName) {

                        if (addingData.hasOwnProperty(propertyName)) {

                            // get this grouping from the global data
                            var groupData = insight.Utils.takeWhere(globalData, 'key', self.dimension.aggregationFunction(addingData))[0].value;

                            // get the group mean from global data for this grouping 
                            var groupMean = groupData[propertyName].Average;

                            var value = addingData[propertyName];
                            var deviation = value - groupMean;
                            var deviationSquared = deviation * deviation;

                            // we need to track each deviation and its square so add them to workings
                            if (!workings[propertyName]) {
                                workings[propertyName] = {
                                    deviation: [],
                                    deviationSquared: []
                                };
                            }

                            workings[propertyName].deviation.push(deviation);
                            workings[propertyName].deviationSquared.push(deviationSquared);

                        }

                    });

                    // having added to the deviation and deviationSquared we can now add 
                    // the product of each pair's deviations to the workings object
                    correlationPairProperties.forEach(function(pair) {

                        var xName = pair[0],
                            yName = pair[1],
                            xDeviation = insight.Utils.lastElement(workings[xName].deviation),
                            yDeviation = insight.Utils.lastElement(workings[yName].deviation),
                            correlationName = deviationProductNameFunction(xName, yName);

                        if (!workings[correlationName]) {
                            workings[correlationName] = [];
                        }

                        workings[correlationName].push(xDeviation * yDeviation);

                    });

                    return workings;

                };

            };

            var correlationReduceRemove = function(aggregatedData) {

                return function() {

                };

            };

            var completeData = self.data.all();

            // the correlationData reduction calculates the deviation squared for 
            // all properties in allCorrelationProperties (a private variable on Grouping)
            var correlationWorkingData = self.dimension.crossfilterDimension.group()
                .reduce(
                    correlationReduceAdd(completeData),
                    correlationReduceRemove(completeData),
                    correlationReduceInitialize)
                .all();

            correlationWorkingData.forEach(function(d) {

                var sum = function(array) {
                    return array.reduce(function(previous, current) {
                        return previous + current;
                    });
                };

                correlationPairProperties.forEach(function(pair) {

                    var xName = pair[0];
                    var yName = pair[1];
                    var deviationProductName = deviationProductNameFunction(xName, yName);
                    var sumDeviationProduct = sum(d.value[deviationProductName]);
                    var sumXDeviationSquared = sum(d.value[xName].deviationSquared);
                    var sumYDeviationSquared = sum(d.value[yName].deviationSquared);

                    var correlationCoefficient = sumDeviationProduct / Math.sqrt(sumXDeviationSquared * sumYDeviationSquared);

                    var thisGroup = completeData.filter(function(item) {
                        return item.key === d.key;
                    })[0];

                    var correlationName = xName + '_Cor_' + yName;
                    thisGroup.value[correlationName] = correlationCoefficient;

                });

            });

        };

        /*
         * Used to calculate any values that need to run after the data set has been aggregated into groups and basic values
         */
        var postAggregationCalculations = function() {

            var totals = {};

            var data = self.ordered() ? self.getData(self.orderFunction()) : self.getData();

            data.forEach(function(d) {

                calculateAverages(d);

                calculateCumulativeValues(d, totals);

            });

            if (correlationPairProperties.length > 0) {

                calculateCorrelations();

            }


            // Run any user injected functions post aggregation
            postAggregation(self);
        };

        /*
         * Called by the map reduce process on a DataSet when an input object is being added to the aggregated group
         * @returns {object} group - The group entry for this slice of the aggregated dataset, modified by the addition of the data object
         * @param {object} group - The group entry for this slice of the aggregated dataset, prior to adding the input data object
         * @param {object} data - The object being added from the aggregated group.
         */
        var reduceAddToGroup = function(group, data) {

            group.Count++;

            var propertyName,
                i,
                len;

            for (i = 0, len = sumProperties.length; i &lt; len; i++) {
                propertyName = sumProperties[i];

                if (data.hasOwnProperty(propertyName)) {
                    group[propertyName].Sum += data[propertyName];
                }
            }

            // Increment the counts of the different occurences of any properties defined. E.g: if a property 'Country' can take multiple string values, 
            // this counts the occurences of each distinct value the property takes
            for (i = 0, len = countProperties.length; i &lt; len; i++) {
                propertyName = countProperties[i];

                var groupProperty = group[propertyName];

                if (data.hasOwnProperty(propertyName)) {

                    var propertyValue = data[propertyName];

                    // If this property holds multiple values, increment the counts for each one.
                    if (insight.Utils.isArray(propertyValue)) {

                        for (var subIndex in propertyValue) {
                            var subVal = propertyValue[subIndex];
                            //Initialize or increment the count for this occurence of the property value
                            group[propertyName][subVal] = groupProperty.hasOwnProperty(subVal) ? groupProperty[subVal] + 1 : 1;
                            group[propertyName].Total++;
                        }
                    } else {
                        group[propertyName][propertyValue] = groupProperty.hasOwnProperty(propertyValue) ? groupProperty[propertyValue] + 1 : 1;
                        group[propertyName].Total++;
                    }
                }
            }

            return group;
        };

        /*
         * Called by the map reduce process on a DataSet when an input object is being filtered out of the group
         * @returns {object} group - The group entry for this slice of the aggregated dataset, modified by the removal of the data object
         * @param {object} group - The group entry for this slice of the aggregated dataset, prior to removing the input data object
         * @param {object} data - The object being removed from the aggregated group.
         */
        var reduceRemoveFromGroup = function(group, data) {

            group.Count--;

            var propertyName,
                i,
                len;

            for (i = 0, len = sumProperties.length; i &lt; len; i++) {
                propertyName = sumProperties[i];

                if (data.hasOwnProperty(propertyName)) {
                    group[propertyName].Sum -= data[propertyName];
                }
            }

            for (i = 0, len = countProperties.length; i &lt; len; i++) {
                propertyName = countProperties[i];

                if (data.hasOwnProperty(propertyName)) {

                    var propertyValue = data[propertyName];

                    if (insight.Utils.isArray(propertyValue)) {

                        for (var subIndex in propertyValue) {
                            var subVal = propertyValue[subIndex];
                            group[propertyName][subVal] = group[propertyName].hasOwnProperty(subVal) ? group[propertyName][subVal] - 1 : 0;
                            group[propertyName].Total--;
                        }

                    } else {
                        group[propertyName][propertyValue] = group[propertyName].hasOwnProperty(propertyValue) ? group[propertyName][propertyValue] - 1 : 0;
                        group[propertyName].Total--;
                    }
                }
            }

            return group;
        };

        /*
         * Called when a slice of an aggrgated DataSet is being initialized, creating initial values for certain properties
         * @returns {object} return - The initialized slice of this aggreagted DataSet.  The returned object will be of the form {key: '
            Distinct Key ', value: {}}
         */
        var reduceInitializeGroup = function() {
            var group = {
                    Count: 0
                },
                propertyName,
                i,
                len;


            for (i = 0, len = sumProperties.length; i &lt; len; i++) {
                propertyName = sumProperties[i];

                group[propertyName] = group[propertyName] ? group[propertyName] : {};
                group[propertyName].Sum = 0;
            }

            for (i = 0, len = countProperties.length; i &lt; len; i++) {
                propertyName = countProperties[i];
                group[propertyName] = group[propertyName] ? group[propertyName] : {};
                group[propertyName].Total = 0;
            }

            return group;
        };

        /*
         * This aggregation method is tailored to dimensions that can hold multiple values (in an array), therefore they are counted differently.
         * For example: a property called supportedDevices : ['iPhone5 ', 'iPhone4 '] where the values inside the array are treated as dimensional slices
         * @returns {object[]} return - the array of dimensional groupings resulting from this dimensional aggregation
         */
        var reduceMultidimension = function() {

            var propertiesToCount = self.count();

            var propertyName,
                i,
                index = 0,
                len,
                gIndices = {};

            function reduceAdd(p, v) {

                for (i = 0, len = propertiesToCount.length; i &lt; len; i++) {

                    propertyName = propertiesToCount[i];

                    if (v.hasOwnProperty(propertyName)) {
                        for (var val in v[propertyName]) {
                            if (typeof(gIndices[v[propertyName][val]]) !== "undefined") {
                                var gIndex = gIndices[v[propertyName][val]];

                                p.values[gIndex].value++;
                            } else {
                                gIndices[v[propertyName][val]] = index;

                                p.values[index] = {
                                    key: v[propertyName][val],
                                    value: 1
                                };

                                index++;
                            }
                        }
                    }
                }
                return p;
            }

            function reduceRemove(p, v) {
                for (i = 0, len = propertiesToCount.length; i &lt; len; i++) {

                    propertyName = propertiesToCount[i];

                    if (v.hasOwnProperty(propertyName)) {
                        for (var val in v[propertyName]) {
                            var property = v[propertyName][val];

                            var gIndex = gIndices[property];

                            p.values[gIndex].value--;
                        }
                    }
                }
                return p;
            }

            function reduceInitial() {

                return {
                    values: []
                };
            }

            var data = self.dimension.crossfilterDimension.groupAll()
                .reduce(reduceAdd, reduceRemove, reduceInitial);

            self.orderFunction(function(a, b) {
                return b.value - a.value;
            });

            return data;
        };


        // Public methods


        /*
         * Gets the function that will run after the map reduce stage of this Grouping's aggregation.This is an empty
         * function by default, and can be overriden by the setter.
         * @instance
         * @memberof! insight.Grouping
         * @returns {function} - The function that will run after aggregation of this Grouping.
         * @also
         * Sets the function that will run after any aggregation has been performed on this Grouping.
         * @instance
         * @memberof! insight.Grouping
         * @returns {this}
         * @param {string[]} postAggregationFunc - A user defined function of the form function(grouping), that the Grouping will run post aggregation.
         */
        self.postAggregation = function(postAggregationFunc) {
            if (!arguments.length) {
                return postAggregation;
            }
            postAggregation = postAggregationFunc;
            return self;
        };

        /*
         * Returns the list of properties to be summed on this Grouping
         * @instance
         * @memberof! insight.Grouping
         * @returns {string[]} - The list of property names that will be summed
         * @also
         * Sets the list of property names that will be summed in this Grouping
         * @instance
         * @memberof! insight.Grouping
         * @returns {this}
         * @param {string[]} properties - An array of property names to be summed for slices in this Grouping.
         */
        self.sum = function(properties) {
            if (!arguments.length) {
                return sumProperties;
            }
            sumProperties = properties;
            return self;
        };

        /*
         * Returns the list of property pairs whose correlation coefficient should be caclulated in this Grouping
         * @instance
         * @memberof! insight.Grouping
         * @returns {Array&lt;String[]>} - The list of property pairs that will be summed.Each pair is an array of two strings
         * @also
         * Sets the list of property pairs whose correlation coefficient should be caclulated in this Grouping
         * @instance
         * @memberof! insight.Grouping
         * @returns {this}
         * @param {Array&lt;String[]>} properties - An array of property pairs whose correlation coefficient should
         * be caclulated in this Grouping
         */
        self.correlationPairs = function(properties) {
            if (!arguments.length) {
                return correlationPairProperties;
            }

            correlationPairProperties = properties;

            for (var i = 0, len = properties.length; i &lt; len; i++) {
                insight.Utils.addToSet(allCorrelationProperties, properties[i][0]);
                insight.Utils.addToSet(allCorrelationProperties, properties[i][1]);
            }

            // need mean for correlation
            averageProperties = insight.Utils.arrayUnique(averageProperties.concat(allCorrelationProperties));

            // need sum for mean so set that too
            sumProperties = insight.Utils.arrayUnique(sumProperties.concat(allCorrelationProperties));

            return self;
        };

        /**
         * Returns the list of properties that will be cumulatively summed over this Grouping
         * @instance
         * @memberof! insight.Grouping
         * @returns {string[]} - The list of property names that will be cumulatively summed
         * @also
         * Sets the list of properties that will be cumulatively summed over this Grouping
         * @instance
         * @memberof! insight.Grouping
         * @returns {this}
         * @param {string[]} properties - An array of property names to be cumulatively summed over slices in this Grouping.
         */
        self.cumulative = function(properties) {
            if (!arguments.length) {
                return cumulativeProperties;
            }
            cumulativeProperties = properties;
            return self;
        };

        /**
         * Returns the array of properties whose distinct value occurences will be counted during the reduction of this Grouping
         * @instance
         * @memberof! insight.Grouping
         * @returns {string[]} - The list of property names whose values will be counted
         * @also
         * Sets the array of properties whose distinct value occurences will be counted during the reduction of this Grouping
         * @instance
         * @memberof! insight.Grouping
         * @returns {this}
         * @param {string[]} properties - An array of properties whose distinct value occurences will be counted during the reduction of this Grouping
         */
        self.count = function(properties) {
            if (!arguments.length) {
                return countProperties;
            }
            countProperties = properties;
            return self;
        };

        /**
         * Returns the array of properties whose mean will be calculated after the map reduce of this Grouping.
         * @instance
         * @memberof! insight.Grouping
         * @returns {string[]} - The list of property names that will averaged
         * @also
         * Sets the array of properties whose mean will be calculated after the map reduce of this Grouping.
         * @instance
         * @memberof! insight.Grouping
         * @returns {this}
         * @param {string[]} properties - An array of properties that will be averaged after the map reduce of this Grouping.
         */
        self.mean = function(properties) {
            if (!arguments.length) {
                return averageProperties;
            }
            averageProperties = properties;

            sumProperties = insight.Utils.arrayUnique(sumProperties.concat(averageProperties));

            return self;
        };

        /**
         * Gets or sets the function used to compare the elements in this grouping if sorting is requested.
         * @instance
         * @memberof! insight.Grouping
         * @returns {function} orderingFunction - The function used to compare two values when sort() is called on an array
         * @also
         * Sets the function used to compare the elements in this grouping if sorting is requested.
         * @instance
         * @memberof! insight.Grouping
         * @returns {this}
         * @param {function} function - The comparison function to be used to sort the elements in this group.
         * The function should take the form of a standard
         * {@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/GlobalvalueObjects/Array/sort|Javascript comparison function}.
         */
        self.orderFunction = function(orderingFunction) {
            if (!arguments.length) {
                return orderFunction;
            }
            orderFunction = orderingFunction;
            return self;
        };


        /**
         * Gets or sets whether the group's data is ordered.
         * @instance
         * @memberof! insight.Grouping
         * @returns {boolean}
         * @also
         * Sets if this Grouping will be ordered or not
         * @instance
         * @memberof! insight.Grouping
         * @returns {this}
         * @param {boolean} ordered - Whether to order this Grouping or not
         */
        self.ordered = function(value) {
            if (!arguments.length) {
                return ordered;
            }
            ordered = value;

            return self;
        };

        /**
         * Gets or sets the function used to filter the results returned by this grouping.
         * @param {function} filterFunction - A function taking a parameter representing an object in the list.
         * The function must return true or false as per
         * &lt;a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/GlobalvalueObjects/Array/filter">Array Filter&lt;/a>.
         */
        self.filter = function(f) {
            if (!arguments.length) {
                return filterFunction;
            }
            filterFunction = f;
            return self;
        };




        /**
         * Called when any post aggregation calculations need to be recalculated.
         * For example, calculating group percentages after totals have been created during map-reduce.
         * @memberof! insight.Grouping
         * @instance
         */
        self.recalculate = function() {

            postAggregationCalculations();
        };

        /**
         * Performs the aggregation of the underlying crossfilter dimension, calculating any additional properties during the map-reduce phase.
         * It must be run prior to a group being used
         * @todo This should probably be run during the constructor? If not, lazily evaluated by getData() if it hasn't been run already.
         */
        self.initialize = function() {

            var basicGroupData;

            if (self.dimension.oneToMany) {
                // Dimensions that are one to many {supportedLanguages: ['EN', 'DE']} as opposed to {supportedLanguage: 'EN'} need to be aggregated differently
                basicGroupData = reduceMultidimension();
            } else {
                // this is crossfilter code.  It calls the crossfilter.group().reduce() functions on the crossfilter dimension wrapped inside our insight.Dimension
                // more info at https://github.com/square/crossfilter/wiki/API-Reference
                // the add, remove and initialie functions are called when crossfilter is aggregating the groups, and is amending the membership of the different 
                // dimensional slices (groups) 
                basicGroupData = self.dimension.crossfilterDimension.group()
                    .reduce(
                        reduceAddToGroup,
                        reduceRemoveFromGroup,
                        reduceInitializeGroup
                );


            }

            self.data = basicGroupData;

            postAggregationCalculations(self);

            return self;
        };


        /**
         * Used to return the group's data, without ordering.  It checks if there is any filtering requested and applies the filter to the return array.
         * @memberof! insight.Grouping
         * @instance
         * @returns {object[]} return - The grouping's data in an object array, with an object per slice of the dimension.
         */
        self.getData = function(orderFunction, top) {
            var data;

            // Set the provided order function if it has been given, otherwise use the inherent grouping order if one has been defined.
            var orderFunc = orderFunction ? orderFunction : self.orderFunction();

            if (!self.data) {
                self.initialize();
            }

            if (self.dimension.oneToMany) {
                data = self.data.value()
                    .values;
            } else {
                data = self.data.all();
            }

            // take a copy of the array to not alter the original dataset
            data = data.slice(0);

            if (orderFunc) {
                data = data.sort(orderFunc);
            }
            if (top) {
                data = data.slice(0, top);
            }

            if (filterFunction) {
                data = data.filter(filterFunction);
            }

            return data;
        };

    };

})(insight);
</code></pre>
        </article>
    </section>





        

        <footer>
            Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.2.2</a>.
        </footer>
    </div>
</div>
<script>prettyPrint();</script>
<script src="scripts/linenumber.js"></script>
<script src="scripts/main.js"></script>
</body>
</html>
